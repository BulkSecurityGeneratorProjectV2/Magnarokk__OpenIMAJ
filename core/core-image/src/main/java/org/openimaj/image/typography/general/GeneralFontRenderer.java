/**
 * 
 */
package org.openimaj.image.typography.general;

import java.awt.Font;
import java.awt.font.FontRenderContext;
import java.awt.font.GlyphVector;
import java.awt.geom.AffineTransform;
import java.awt.geom.CubicCurve2D;
import java.awt.geom.GeneralPath;
import java.awt.geom.PathIterator;
import java.awt.geom.QuadCurve2D;
import java.util.ArrayList;
import java.util.List;

import org.openimaj.image.renderer.ImageRenderer;
import org.openimaj.image.typography.FontRenderer;
import org.openimaj.math.geometry.point.Point2dImpl;
import org.openimaj.math.geometry.shape.Polygon;
import org.openimaj.math.geometry.shape.Rectangle;

import com.caffeineowl.graphics.bezier.BezierUtils;
import com.caffeineowl.graphics.bezier.CubicSegmentConsumer;
import com.caffeineowl.graphics.bezier.QuadSegmentConsumer;
import com.caffeineowl.graphics.bezier.flatnessalgos.SimpleConvexHullSubdivCriterion;

/**
 *	A font renderer that takes the glyph outline as generated by the
 *	Java AWT Font system and renders it into an OpenIMAJ image using the
 *	ImageRenderer methods.
 *
 *	@author David Dupplaw <dpd@ecs.soton.ac.uk>
 *  @created 18 Aug 2011
 *	@version $Author$, $Revision$, $Date$
 *
 *	@param <T> The image pixel type
 */
public class GeneralFontRenderer<T> extends FontRenderer<T,GeneralFontStyle<T>>
{
	/**
	 *	@inheritDoc
	 * 	@see org.openimaj.image.typography.FontRenderer#renderText(org.openimaj.image.renderer.ImageRenderer, java.lang.String, int, int, org.openimaj.image.typography.FontStyle)
	 */
	@Override
	public void renderText( ImageRenderer<T, ?> renderer, String text, 
			int x, int y, GeneralFontStyle<T> style )
	{
		List<Polygon> p = getPolygons( text, x, y, style );
		
		if( style.isOutline() )
		{
			for( Polygon poly : p )
				renderer.drawPolygon( poly, style.getColour() );			
		}
		else
		{
			for( Polygon poly : p )
				renderer.drawPolygonFilled( poly, style.getColour() );
		}
	}

	/**
	 * 	Returns a list of polygons that represent the letters in the given
	 * 	text. If the font style is outline, the holes will be delivered as
	 * 	separate polygons otherwise they will be integrated into the letter
	 * 	polygons.
	 * 
	 *	@param text The text to render as a polygon
	 *	@param x The x-coordinate
	 *	@param y The y-coordinate
	 *	@param style The font's style
	 *	@return A list of polygons
	 */
	public List<Polygon> getPolygons( String text, 
			int x, int y, GeneralFontStyle<T> style )
	{
		List<Polygon> letters = new ArrayList<Polygon>();
		
		Font f = new Font( 
				style.getFont().getName(),
				style.getFont().getType(),
				(int)style.getFont().getSize() );
		
		FontRenderContext frc = new FontRenderContext( 
				new AffineTransform(), true, true );
		GlyphVector g = f.createGlyphVector( frc, text.toCharArray() );
		
		Polygon currentPoly = null;
		for( int i = 0; i < g.getNumGlyphs(); i++ )
		{
			GeneralPath s = (GeneralPath)g.getGlyphOutline( i, x, y );
			PathIterator pi = s.getPathIterator( new AffineTransform() );
			
			float[] ps = new float[6];
			float xx = 0, yy = 0;
			while( !pi.isDone() )
			{
				int t = pi.currentSegment( ps );
				
				switch( t )
				{
					case PathIterator.SEG_MOVETO:
					{
						if( !style.isOutline() )
						{
							if( currentPoly != null )
							{
								if( !currentPoly.isInside( 
									new Point2dImpl(ps[0],ps[1])) )
								{
									letters.add( currentPoly );
									currentPoly = new Polygon();
								}
								else
								{
									currentPoly.addVertex( currentPoly.getVertices().get(0) );
								}
							}
							else
								currentPoly = new Polygon();
						}
						else
						{
							currentPoly = new Polygon();
						}
						
						currentPoly.addVertex( ps[0], ps[1] );
						xx = ps[0]; yy = ps[1];
						break;
					}
					case PathIterator.SEG_LINETO:
					{
						currentPoly.addVertex( ps[0], ps[1] );
						xx = ps[0]; yy = ps[1];
						break;
					}
					case PathIterator.SEG_QUADTO:
					{
				        QuadCurve2D c = new QuadCurve2D.Double(
			            	xx, yy, ps[0], ps[1], ps[2], ps[3] );
				        final Polygon p = currentPoly;
			    		BezierUtils.adaptiveHalving( c , new SimpleConvexHullSubdivCriterion(), 
			            	new QuadSegmentConsumer()
			    			{
			    				public void processSegment( QuadCurve2D segment, double startT, double endT )
			    				{
			    					if( 0.0 == startT )
			    						p.addVertex( new Point2dImpl( 
			    								(float)segment.getX1(), (float)segment.getY1() ) );
			    					
			    					p.addVertex( new Point2dImpl( 
			    							(float)segment.getX2(), (float)segment.getY2() ) );
			    				}
			    			}
			            );
						xx = ps[2]; yy = ps[3];						
						break;
					}
					case PathIterator.SEG_CUBICTO:
					{
				        CubicCurve2D c = new CubicCurve2D.Double(
				            	xx, yy, ps[0], ps[1], 
				            	ps[2], ps[3], ps[4], ps[5] );
				        final Polygon p = currentPoly;
				    	BezierUtils.adaptiveHalving( c , new SimpleConvexHullSubdivCriterion(), 
			            	new CubicSegmentConsumer()
			    			{				
			    				public void processSegment( CubicCurve2D segment, 
			    						double startT, double endT )
			    				{
			    					if( 0.0 == startT )
			    						p.addVertex( new Point2dImpl( 
			    								(float)segment.getX1(), (float)segment.getY1() ) );
			    					
			    					p.addVertex( new Point2dImpl( 
			    							(float)segment.getX2(), (float)segment.getY2() ) );
			    				}
			    			}
			            );
						xx = ps[4]; yy = ps[5];
			    		break;
					}
					case PathIterator.SEG_CLOSE:
					{
						currentPoly.addVertex( ps[0], ps[1] );
						letters.add( currentPoly );
						break;
					}
				}
				
				pi.next();
			}
		}

		return letters;
	}
	
	/**
	 *	@inheritDoc
	 * 	@see org.openimaj.image.typography.FontRenderer#getBounds(java.lang.String, org.openimaj.image.typography.FontStyle)
	 */
	@Override
	public Rectangle getBounds( String string, GeneralFontStyle<T> style )
	{
		Rectangle bounds = new Rectangle(0,0,Float.MIN_VALUE,Float.MIN_VALUE);

		List<Polygon> polys = getPolygons( string, 0, 0, style );
		for( Polygon p : polys )
		{
			bounds.x = (float) Math.min( bounds.x, p.minX() );
			bounds.y = (float) Math.min( bounds.y, p.minY() );
			bounds.width = (float) Math.max( bounds.width, p.maxX() - bounds.x);
			bounds.height = (float) Math.max( bounds.height, p.maxY() - bounds.y);
		}
		
		return bounds;
	}
}
