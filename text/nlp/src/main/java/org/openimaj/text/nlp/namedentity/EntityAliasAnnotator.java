package org.openimaj.text.nlp.namedentity;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.apache.commons.lang.StringUtils;
import org.openimaj.ml.annotation.ScoredAnnotation;
import org.openimaj.text.nlp.namedentity.NGramGenerator.StringNGramGenerator;

/**
 * An {@link EntityAnnotator} based around looking up unigrams, bigrams and
 * trigrams in maps. This annotator serves as a simple interface to a map of
 * aliases, an example producer of such maps of aliases is the
 * {@link YagoLookupMapFactory}
 * 
 * @author Laurence Willmore (lgw1e10@ecs.soton.ac.uk)
 * @author Sina Samangooei (ss@ecs.soton.ac.uk)
 * 
 */
public class EntityAliasAnnotator extends EntityAnnotator {

	private final HashMap<String, ArrayList<String>> lookupMap;
	private final StopWordStripper ss;
	private final boolean verbose = false;

	/**
	 * @param lookupMap
	 *            HashMap generated by {@link YagoLookupMapFactory}.
	 *            YagoLookupMapBuilder is a tool for using the factory.
	 */
	public EntityAliasAnnotator(HashMap<String, ArrayList<String>> lookupMap) {
		super();
		this.lookupMap = lookupMap;
		ss = new StopWordStripper(StopWordStripper.Language.ENGLISH);
	}

	@Override
	public Set<HashMap<String, Object>> getAnnotations() {
		return null;
	}

	@Override
	public List<ScoredAnnotation<HashMap<String, Object>>> annotate(List<String> tokens) {
		// get Ngram entities
		final Map<Integer, HashMap<String, Object>> m1 = getNgramEntities(1, tokens);
		print("Unigrams");
		for (final int ind : m1.keySet()) {
			print(ind + " : " + m1.get(ind));
		}
		final Map<Integer, HashMap<String, Object>> m2 = getNgramEntities(2, tokens);
		print("Bigrams");
		for (final int ind : m2.keySet()) {
			print(ind + " : " + m2.get(ind));
		}
		final Map<Integer, HashMap<String, Object>> m3 = getNgramEntities(3, tokens);
		print("Trigrams");
		for (final int ind : m3.keySet()) {
			print(ind + " : " + m3.get(ind));
		}
		// check for single token collisions
		for (final int i : m1.keySet()) {
			boolean collision = false;
			for (final int j : m2.keySet()) {
				if (j > i)
					break;
				if (i == j || i == j + 1) {
					collision = true;
					break;
				}
			}
			if (!collision)
				for (final int j : m3.keySet()) {
					if (j > i)
						break;
					if (i >= j && i <= j + 2) {
						collision = true;
						break;
					}
				}
			if (!collision)
				m3.put(i, m1.get(i));
		}
		// check for bigram collisions
		for (final int i : m2.keySet()) {
			boolean collision = false;
			for (final int j : m3.keySet()) {
				if (j > i)
					break;
				if (i == j || i == j + 1) {
					collision = true;
					break;
				}
			}
			if (!collision)
				m3.put(i, m2.get(i));
		}
		final ArrayList<ScoredAnnotation<HashMap<String, Object>>> rr = new ArrayList<ScoredAnnotation<HashMap<String, Object>>>();
		for (final HashMap<String, Object> ent : m3.values()) {
			rr.add(new ScoredAnnotation<HashMap<String, Object>>(ent, 1));
		}
		return rr;
	}

	private ArrayList<String> getYagoCandidates(String token) {
		if (lookupMap.containsKey(token))
			return lookupMap.get(token);
		else
			return null;
	}

	private HashMap<Integer, HashMap<String, Object>> getNgramEntities(int n, List<String> baseTokens) {
		final List<String[]> ngrams = new StringNGramGenerator().getNGrams(baseTokens, n);
		final List<String> tokens = new ArrayList<String>();
		for (int i = 0; i < ngrams.size(); i++) {
			tokens.add(StringUtils.join(ngrams.get(i), " "));
		}
		final HashMap<Integer, HashMap<String, Object>> result = new HashMap<Integer, HashMap<String, Object>>();
		// Try and match ngrams
		for (int i = 0; i < tokens.size(); i++) {
			final String token = tokens.get(i);
			if (!ss.isStopWord(token)) {
				final ArrayList<String> matches = getYagoCandidates(token);
				if (matches != null) {
					final HashMap<String, Object> entity = new HashMap<String, Object>();
					entity.put(URIS, matches);
					entity.put(START_TOKEN, i);
					entity.put(END_TOKEN, i - 1 + n);
					entity.put(TYPE, "Company");
					result.put(i, entity);
				}
			}
		}
		return result;
	}

	private void print(String message) {
		if (verbose)
			System.out.println(message);
	}

}
